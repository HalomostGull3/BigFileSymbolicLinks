# Dane MacFadden
# dgm288
# 11283087
#
# James Hom
# jhh318
# 11287431

Part A documentation

To support double indirect blocks I had to change fs.h. I changed NDIRECT to 11
to make room for our new block. I added NDOUBLY_INDIRECT which is the number of
blocks that our new block will be able to access 
(256 * 256 or NINDIRECT * NINDIRECT). In the dinode struct I changed the size 
of the addr array to hold our new block. I did this in the inode
struct in file.h too.
I had to change MAXFILE since we can now have a larger file. 
I changed it to the number of direct blocks plus the number of 
indirect blocks plus the number of doubly indirect blocks
(INDIRECT + NINDIRECT + NDOUBLY_INDIRECT). I also modified bmap in fs.c.
After xv6's implementation of single indirect blocks I 
subtract the number of indirect blocks in the system from bn.
Then, if the number is less than the max number of indirect
blocks, we know this file will fit in the system. 
If the block at ip->addrs[NDIRECT + 1] is zero, we know that we haven't
made a double indirect block yet, so we allocate that block and set 
addrs[NDIRECT+1] to that newly allocated block. Then, we bread the block
and get a pointer to its data. Idx is the index in a of the next block to
load, given by bn/NINDIRECT, so we check if that block is empty and 
allocate if it is. If balloc returns zero that means we're out of blocks.
Since addr = balloc(), we check the value of addr. If addr is non zero
then it successfully allocated a block and we can safely set a[idx] to addr
and write bp to the log. Then brelse(bp) because we're going to bread a new
buffer into bp. We have to reset a to a pointer to bp->data here so that we
get the new block's data. Then we calculate the offset we want to access, which
would be similar to idx but one layer deeper if that makes sense. Then we again
check if we can fit a block there and allocate a new block and write to the log
if we can. Then we just brelse(bp) and return the addr.
I modified itrunc to clean out the doubly indirect block references.
I added another buffer and another uint (nextbp and nexta respectively). Then
I check if there's a double indirect block. If there is, we set bp and
a as we've done before. Then we loop over every entry in the first layer and
check for used blocks. Then we have an inner loop to once again check for used
blocks, freeing any we find. Then when we exit the inner loop, we free the one
that the outer loop is on. After we exit that loop, we change ip->size to zero
because the inode will now be empty. We finish by writing that inode to disk 
with iupdate.